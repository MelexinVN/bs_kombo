/*
* main.c
* Пример ведущего устройства с модулем NRF24L01.
* Проект "КомБО" (Открытые системы беспроводной коммуникации)
* База системы опроса игровых кнопок
*
* Микроконтроллеры: ATmega8/48/88/168/328
*
* фьюзы ATmega8:				High: 0xD8, Low: 0xE4
* фьюзы ATmega48/88/168/328:	High: 0xDF, Low: 0xE2
*
* Подключение периферии:
* NRF24L01		ATmega8/48/88/168/328	Arduino nano(UNO)
* CE			PB0(12)					D8
* CSN			PD7(11)					D7
* SCK			PB5(17)					D13
* MOSI			PB3(15)					D12
* MISO			PB4(16)					D11
* IRQ			PD2(32)					D2
*
* LED			ATmega8/48/88/168/328	Arduino nano(UNO)
*				PD6(10)					D6
*
* USART			ATmega8/48/88/168/328	Arduino nano(UNO)
* TX			PD0(30)					D0
* RX			PD1(31)					D1
*
*   Краткое описание работы:
* При включении питания и сбросе в порт выдаются значения регистров радиомодуля
* В процессе работы устройство по кругу отправляет запросы и команды на адреса игровых кнопок, содержащиеся в массиве
* при получении ответа на запрос, в порт выдается адрес, с которого получен ответ и полученные данные 
* (состояние кнопки или время прошедшее с последнего нажатия). 
* Данные анализируются (определяется последовательность нажатий, формируется очередь и тд.), 
* и в зависимости от результатов игровым кнопкам рассылаются команды управления светодиодами (зажечь или погасить).
* Через последовательный порт устройство принимает команды и сброса кнопок и перехода очереди.
*
* Автор: Мелехин В.Н. (MelexinVN)
*/

#include "main.h"						//подключаем основной заголовочный файл

//Переменные и массивы
char str[STRING_SIZE] = {0};			//буфер для вывода в порт
uint8_t slave_counter = 0;				//счетчик ведомых
uint8_t slave_addrs[] = ADRESS_LIST;	//массив адресов ведомых
volatile uint8_t ms_counter = 0;		//счетчик милисекунд
//Флаги
volatile uint8_t f_but_rst = 1;	//флаг сброса кнопок
volatile uint8_t f_but_next = 0;//флаг перехода очереди
//Внешние переменные, массивы и флаги
extern volatile char rx_str[UART_RX_BUFFER_SIZE];	//приемная строка порта
extern volatile uint8_t f_uart_rec;					//флаг приема данных из порта
extern volatile uint8_t f_rx, f_tx;		//флаги приема и передачи
extern uint8_t tx_buf[TX_PLOAD_WIDTH];	//буфер передачи
extern uint8_t rx_buf[TX_PLOAD_WIDTH];	//буфер приема
volatile int led_st;				//состояние текущего светодиода

//Переменные и массивы работы с кнопками
//Массивы
uint8_t led_stat[NUM_OF_SLAVES] = {0x00};			//массив текущих состояний светодиодов кнопок
uint8_t but_push_order[NUM_OF_SLAVES] = {0x00};		//массив очереди нажатий
uint8_t but_cmnds[NUM_OF_SLAVES] = {0x01};			//массив команд для кнопок
uint32_t but_times[NUM_OF_SLAVES] = {MAX_TIME};		//массив хранения значений времени, присланых кнопками
uint8_t f_pushed_but[NUM_OF_SLAVES] = {0};			//массив флагов нажатия кнопок
//Переменные
uint32_t min_time = MAX_TIME;			//для поиска минимального значения времени
uint8_t j_min = 0;						//индекс минимального значения в массиве
uint8_t first_led_stat = 0;				//состояние первого в очережи светодиода

//Процедура сортировки данных по возрастанию
void sort_data(uint32_t *data)
{
	for(uint8_t i = 0 ; i < NUM_OF_SLAVES - 1; i++)
	{
		for(uint8_t j = 0 ; j < NUM_OF_SLAVES - i - 1 ; j++)
		{
			if(data[j] > data[j+1]) 		//сравниваем два соседних элемента.
			{           					//если они идут в неправильном порядке, то
				uint32_t tmp = data[j];		//меняем их местами.
				data[j] = data[j+1];
				data[j+1] = tmp;
			}
		}
	}
}

//Процедура сброса по команде сброса из порта
void reset_buttons(void)
{
	tx_buf[0] = SOFT_RESET;		//записываем команду на сброс в буфер
	tx_buf[1] = 0x01;			//значение по умолчанию
	tx_buf[2] = 0x00;			//значение по умолчанию
	nrf24_send(tx_buf);			//отправка в эфир посылки
	for (uint8_t i = 0; i < NUM_OF_SLAVES; i++)
	{//установка значений по умолчанию в массивы
		but_cmnds[i] = 0x01;	//команд
		led_stat[i] = 0x00;		//состояния светодиодов
		but_times[i] = MAX_TIME;//времени
		but_push_order[i] = 0x00;//очереди
		f_pushed_but[i] = 0;	//флагов нажатий
	}
	min_time = MAX_TIME;		//значения по умолчанию
	f_but_rst = 0;				//опускаем флаг
	_delay_ms(500);				//задержка для корректной работы сброса
}								//в случае сбоев можно попробовать увеличить

//Процедура формирования очереди нажатий
void push_order_form(void)
{
	//вспомогательный массив для сортировки времени
	uint32_t times_for_sort[NUM_OF_SLAVES] = {MAX_TIME};
	//заполняем увспомогательный массив
	for (uint8_t i = 0; i < NUM_OF_SLAVES; i++)	//цикл по всем кнопкам
	{
		times_for_sort[i] = but_times[i];		//сохраняем времена во вспомогательный массив
	}
	
	sort_data(times_for_sort);					//сортируем массив 

	for (uint8_t i = 0; i < NUM_OF_SLAVES; i++)	//цикл по всем кнопкам
	{
		if (but_times[i] < MAX_TIME) 			//если данная кнопка была нажата
		{
			for (uint8_t j = 0; j < NUM_OF_SLAVES; j++)	//цикл по всем кнопкам
			{//если время текущей кнопки совпадает с индексом времени в отсортированном массиве
				if (times_for_sort[j] == but_times[i])
				{//присваиваем значение индекса соответствующему элементу массива очереди
					but_push_order[i] = j + 1;
				}
			}
		}
	}
	//далее определяем какое состояние задать светодиодам
	for (uint8_t i = 0; i < NUM_OF_SLAVES; i++)//цикл по всем кнопкам
	{
		if (but_push_order[i])		//если номер в очереди не нулевой (кнопка была нажата)
		{//если номер первый, записываем команду моргающей кнопки
			if (but_push_order[i] == 1) led_stat[i] = first_led_stat;
			//если номер не первый, просто зажигаем светодиод
			else led_stat[i] = LED_STATE_ON;
		}
	}
}

//Процедура обработки перехода очереди по нажатию определенной кнопки или команды из порта
void push_order_shift(void)
{
	f_but_next = 0;					//опускаем флаг нажатия кнопки
	//вносим изменения в очередь
	for (uint8_t i = 0; i < NUM_OF_SLAVES; i++)//цикл по всем кнопкам
	{
		if (but_push_order[i])		//если кнопка была нажата (значение не 0)
		{
			if (but_push_order[i] == 1)			//если номер в очереди - первый
			{
				but_push_order[i] = 0x00;		//обнуляем номер в очереди
				but_times[i] = MAX_TIME;		//устанавливаем начальное значение времени
				led_stat[i] = LED_STATE_OFF;	//записываем команду отключения светодиода
				but_cmnds[i] = SOFT_RESET;		//записываем команду сброса кнопки
				tx_buf[0] = slave_addrs[i];		//адрес текущей кнопки к отправке
				tx_buf[1] = but_cmnds[i];		//команда текущей кнопки к отправке
				tx_buf[2] = led_stat[i];		//статус текущего статуса светодиода к отправке
				nrf24_send(tx_buf);				//отправляем
				but_cmnds[i] = 0x01;			//устанавливаем следующую команду на управление светодиодом
			}
			else but_push_order[i]--;			//если порядок не 0 и не 1, уменьшаем его
		}
	}
	_delay_ms(500);								//задержка для корректной работы перехода очереди
}												//в случае сбоев можно попробовать увеличить

//Процедура обработки прерывания по сравнению А таймера 1
void t1_compa_callback(void)
{
	ms_counter++;			//считаем мс
	if (ms_counter >= LED_BLINK_PERIOD)	//если отсчитано нужное количество мс
	{
		//меняем состояние на противоположное
		if (first_led_stat == LED_STATE_ON) first_led_stat = LED_STATE_OFF;
		else first_led_stat = LED_STATE_ON;
		ms_counter = 0;		//обнуляем счетчик милисекунд
	}
	wdt_reset();			//сбрасываем сторожевой таймер
}

//Вектор прерывания по сравнению А таймера 1
ISR(TIMER1_COMPA_vect)
{
	t1_compa_callback();	//обрабатываем прерывание
}

//Процедура инициализации портов ввода вывода
void gpio_init(void)
{
	LED_DDR |= 1<<LED_DD;	//пин светодиода на выход
	LED_PORT |= 0<<LED_PIN;	//низкий уровень на выводе светодиода
}

//Процедура инициализации прерываний
void interrupt_init(void)
{
	//включаем внешнее прерывания INT0 по спаду
	//и прерывание по сравнению А таймера 1
	#ifdef ATMEGA8
	GICR|=(0<<INT1) | (1<<INT0);
	MCUCR=(0<<ISC11) | (0<<ISC10) | (1<<ISC01) | (0<<ISC00);
	GIFR=(0<<INTF1) | (1<<INTF0);
	
	TIMSK=(1<<OCIE2) | (0<<TOIE2) | (0<<TICIE1) | (1<<OCIE1A) | (0<<OCIE1B) | (0<<TOIE1) | (0<<TOIE0);
	#endif
	
	#ifdef ATMEGA88
	EICRA=(0<<ISC11) | (0<<ISC10) | (1<<ISC01) | (0<<ISC00);
	EIMSK=(0<<INT1) | (1<<INT0);
	EIFR=(0<<INTF1) | (1<<INTF0);
	PCICR=(0<<PCIE2) | (0<<PCIE1) | (0<<PCIE0);
	
	TIMSK1=(0<<ICIE1) | (0<<OCIE1B) | (1<<OCIE1A) | (0<<TOIE1);
	#endif
}

//Процедура приема радиомодуля
void nrf24l01_receive(void)
{
	if(f_rx)	//если флаг приема поднят (флаг поднимается по внешнему прерыванию от радиомодуля)
	{
		if ((*(unsigned long*)&rx_buf[1]) != NOT_PUSH_CMD)
		{	//если время, присланное кнопкой не максимально возможное (кнопка нажата)

			unsigned long time = *(unsigned long*)&rx_buf[1];	//преобразуем оставшиеся байты во время

			//определяем по адресу номер кнопки
			for (uint8_t i = 0; i < NUM_OF_SLAVES; i++)
			{//перебираем все кнопки
				if (rx_buf[0] == slave_addrs[i]) 	//если найден принятый адрес
				{
					but_times[i] = time;			//записываем время в массив времен
					sprintf(str," %X\t%lu\r\n",i,time);	//формируем строку
					usart_print(str);					//отправляем строку в порт
				}	//не выходим из цикла при найденной кнопке чтобы для всех обработок были одинаковые тайминги
			}
		}
	
		else
		{	//кнопка не нажата не нажата
			for (uint8_t i = 0; i < NUM_OF_SLAVES; i++)
			{//перебираем все кнопки
				if (rx_buf[0] == slave_addrs[i]) 	//если найден принятый адрес
				{
					but_times[i] = MAX_TIME;		//записываем максимальное время в массив времен
					sprintf(str,"%X\tnp\r\n",i);	//формируем строку
					usart_print(str);				//отправляем в порт
				}	//не выходим из цикла при найденной кнопке чтобы для всех обработок были одинаковые тайминги
			}
		}
	}
	f_rx = 0;		//опускаем флаг приема
}

//Процедура моргания светодиодом
void blink_led(uint8_t blink_counter)
{
	while (blink_counter)	//пока счетчик не равен 0
	{
		LED_ON();			//включаем светодиод
		_delay_ms(10);		//ждем
		LED_OFF();			//выключаем светодиод
		_delay_ms(50);		//ждем
		blink_counter--;	//декрементируем счетчик
	}
}

//Вектор прерывания от последовательного порта
#ifdef ATMEGA88
ISR(USART_RX_vect)
{
	char input_char = UDR0;			//получаем байт из регистра данных
	
	if (input_char == CMD_RESET) 	//если полученный байт - команда сброса
	{
		reset_buttons();			//запускаем процедуру сброса
	}
	
	if (input_char == CMD_NEXT) 	//если полученный байт - команда перехода очереди
	{
		push_order_shift();			//запускаем процедуру перехода очереди
	}
}
#endif

#ifdef ATMEGA8
ISR(USART_RXC_vect)
{
	char input_char = UDR;			//получаем байт из регистра данных
	
	if (input_char == CMD_RESET) 	//если полученный байт - команда сброса
	{
		reset_buttons();			//запускаем процедуру сброса
	}
	
	if (input_char == CMD_NEXT) 	//если полученный байт - команда перехода очереди
	{
		push_order_shift();			//запускаем процедуру перехода очереди
	}
}
#endif

//Вектор прерывания INT0
ISR(INT0_vect)
{
	irq_callback();					//обрабатываем прерывание от радиомодуля
}

// Процедура инициализации таймера 1
void timer_init(void)
{
	//Частота тактирования: 125,000 kHz
	//Режим: CTC top=OCR1A (сброс по совпадению)
	//Выходы отключены
	//Период : 1 мс
	//Включено прерывание по совпадению
	#ifdef ATMEGA8
	TCCR1A=(0<<COM1A1) | (0<<COM1A0) | (0<<COM1B1) | (0<<COM1B0) | (0<<WGM11) | (0<<WGM10);
	TCCR1B=(0<<ICNC1) | (0<<ICES1) | (0<<WGM13) | (1<<WGM12) | (0<<CS12) | (1<<CS11) | (1<<CS10);
	TCNT1H=0x00;
	TCNT1L=0x00;
	ICR1H=0x00;
	ICR1L=0x00;
	OCR1AH=0x00;
	OCR1AL=0x7C;
	OCR1BH=0x00;
	OCR1BL=0x00;
	#endif
	
	#ifdef ATMEGA88
	TCCR1A=(0<<COM1A1) | (0<<COM1A0) | (0<<COM1B1) | (0<<COM1B0) | (0<<WGM11) | (0<<WGM10);
	TCCR1B=(0<<ICNC1) | (0<<ICES1) | (0<<WGM13) | (1<<WGM12) | (0<<CS12) | (1<<CS11) | (1<<CS10);
	TCNT1H=0x00;
	TCNT1L=0x00;
	ICR1H=0x00;
	ICR1L=0x00;
	OCR1AH=0x00;
	OCR1AL=0x7C;
	OCR1BH=0x00;
	OCR1BL=0x00;
	#endif
}

//Процедура вывода в порт данных из регистров радиомодуля
void nrf_info_print(void)
{
	uint8_t buf[TX_ADR_WIDTH] = {0};				//буфер для чтения адресов модуля
	uint8_t dt_reg = 0;								//переменная для чтения значения регистра
	
	dt_reg = nrf24_read_reg(CONFIG);				//читаем регистр CONFIG
	sprintf(str, "CONFIG: 0x%02X\r\n", dt_reg);		//
	usart_print(str);								//выводим данные в порт
	dt_reg = nrf24_read_reg(EN_AA);					//читаем регистр EN_AA
	sprintf(str, "EN_AA: 0x%02X\r\n", dt_reg);		//
	usart_print(str);								//выводим данные в порт
	dt_reg = nrf24_read_reg(EN_RXADDR);				//читаем регистр EN_RXADDR
	sprintf(str, "EN_RXADDR: 0x%02X\r\n", dt_reg);	//
	usart_print(str);								//выводим данные в порт
	dt_reg = nrf24_read_reg(STATUS);				//читаем регистр STATUS
	sprintf(str, "STATUS: 0x%02X\r\n", dt_reg);		//
	usart_print(str);								//выводим данные в порт
	dt_reg = nrf24_read_reg(RF_SETUP);				//читаем регистр RF_SETUP
	sprintf(str, "RF_SETUP: 0x%02X\r\n", dt_reg);	//
	usart_print(str);								//выводим данные в порт
	nrf24_read_buf(TX_ADDR,buf,3);					//читаем буфер TX_ADDR
	sprintf(str, "TX_ADDR: 0x%02X, 0x%02X, 0x%02X\r\n", buf[0], buf[1], buf[2]);
	usart_print(str);								//выводим данные в порт
	nrf24_read_buf(RX_ADDR_P1,buf,3);				//читаем буфер RX_ADDR_P1
	sprintf(str, "RX_ADDR: 0x%02X, 0x%02X, 0x%02X\r\n", buf[0], buf[1], buf[2]);
	usart_print(str);								//выводим данные в порт
}


int main(void)
{
	spi_init();				//инициализируем SPI
	//_delay_ms(1000);		//задержка для корректного включения SPI
	//(в некоторых случаях отсутствие задержки или недостаточная задержка по времени приводила к уходу в ребут при включении питания)
	interrupt_init();		//инициализируем прерывания
	gpio_init();			//инициализируем порты ввода-вывода
	timer_init();			//инициализируем таймер
	usart_init(103);		//инициализируем USART 9600 бод
	//usart_init(8);		//инициализируем USART 115200 бод
	usart_println("start");	//отправка стартовой строки в порт
	nrf24_init();			//инициализируем радиомодуль
	blink_led(5);			//моргаем светодиодом
	nrf_info_print();		//выводим значения регистров в порт
	
	wdt_enable(WDTO_500MS);	//включаем сторожевой таймер
	
	sei();					//глобальное разрешение прерываний
	
	while (1)
	{
		//обработка команды сброса
		if (f_but_rst)
		{//если нажата кнопка сброса или пршла команда сброса
			reset_buttons();
		}
		else
		{//если нет команды сброса, запись в буфер
			tx_buf[0] = slave_addrs[slave_counter];	//адреса текущей кнопки
			tx_buf[1] = but_cmnds[slave_counter];	//команды
			tx_buf[2] = led_stat[slave_counter];	//статуса светодиода
			nrf24_send(tx_buf);						//отправка посылки в эфир
			slave_counter++;						//переход к следующей кнопке
			if (slave_counter == NUM_OF_SLAVES)
			{
				slave_counter = 0;					//или к нулевой кнопке
			}
		}
		//формируем очередь нажатий
		push_order_form();
		
		if(f_but_next)	//если поднят флаг перехода очереди
		{
			push_order_shift();	//сдвигаем очередь
		}
		
		//_delay_ms(1);	//задержка (при большом количестве ведомых устройств может не потребоваться)
		
		//задержка необходима, чтобы ведомое устройство успело получить запрос, отправить ответ,
		//а данное ведущее устройство успело получить и обработать отет на запрос, прежде чем
		//переходить к отправке следующего
		
		//для достижения максимального быстродействия величину задержки необходимо подбирать наименьшей
		//экспериментально с учетом времени, затрачиваемого на остальные действия микроконтроллера
		
		nrf24l01_receive();		//обрабатываем прием радиомодуля
		
		wdt_reset();			//сбрасываем сторожевой таймер
	}
}

